<div dir="rtl">

# آموزش کامل آپاچی

## آپاچی چیست

آپاچی ابزاری برای مجهز کردن یک سرور به درگاه Http  یا HTTPS هست

توسط این ابزار میتوانیم کاری کنیم که هر کسی اگر ip address ما رو زد و یا domain name ما رو داشت redirect بشه به DocumentRoot یی که برای اون دامین تعریف کردیم

آپاچی یکی از معروف ترین ابزارهای HTTP برای سرورها هست

در اینجا به علت اینکه ویندوز 10 مجهز به لینوکس شده میتوان آموزش رو یکسان انجام داد

## روش نصب آپاچی بر روی لینوکس و لینوکس ویندوز

برای نصب کافی هست که در ترمینال بنویسیم

<div dir="ltr">

```
sudo apt install apache2 -y
```
</div>

و برای اینکه آپاچی خودمون رو بر روی سیستم ران کنیم مینویسیم

و ورژنی که باید سیستم بتواند بر روی سیستم شما نصب کند 2.4 و یا جدیدتر
<div dir="ltr">

```
sudo service apache2 start
```
</div>

## دستورات مورد نیاز برای آپاچی
ابتدا بهتر هست که با یک سری دستورات در ترمینال آشنا بشیم که در آینده بسیار قراره ازشون استفاده کنیم

قطعا یکی از راه های استارت کردن آپاچی و یا ری استارت کردن توسط دستور `Service` هست اما دستور دیگری وجود دارد به نام `apachectl` که میتواند همین کار و کارهای دیگر رو انجام دهد کافی هست که این دستور رو درون ترمینال وارد کنید که خودش به شما میگه که چه کارهایی رو میتوان انجام داد

### ری استارت و یا استارت و یا متوقف کردن آپاچی

کافی هست برای اینکار بنویسیم
<div dir="ltr">

```
sudo apachectl start | stop | restart
```
</div>

### گرفتن اطلاعات و یا اطلاعات بیشتر درمورد مشکل پیش رو در آپاچی

بعضی اوقات ممکن هست که شما دچار مشکلاتی بشید یا میخواهید وضعیت آپاچی خودتون رو بدونید کافی هست که برای این دستورات بنویسید

<div dir="ltr">

```
sudo apachectl status | fullstatus | configtest
```
</div>
به طور مثال با دستور `configtest` میتونید از مشکلات در syntax فایل ها متوجه بشید و یا اگر نوشت syntax ok به معنی آن هست که آپاچی شما مشکل نوشتاری ندارد

### چگونه متوجه بشید که چه ماژولی بر روی سیستم آپاچی شما نصب هست

کافی هست که دستور زیر رو اجرا کنید که متوجه بشید چه ماژولی در حال حاظر فعال هست

<div dir="ltr">

```
sudo apachectl -M
```
</div>

### چگونه ماژولی رو فعال و یا غیر فعال کنیم

اگر دقت کرده باشید درون دایرکتوری `apache2` شما دو پوشه به نام های `mods-enabled` و `mods-avaliable` داریم 

دایرکتوری `mods-avaliable` دایرکتوری هست که تمام ماژول ها و افزونه های آپاچی درون اونجا قرار داره که غیر فعال هستند و اگر بخواهیم اونها رو فعال کنیم باید وارد دایرکتوری `mods-enabled` بکنیم

برای اینکار کافی هست بنویسیم

<div dir="ltr">

```
sudo a2enmod <module name>

for example

sudo a2enmod deflate
```
</div>

دستور a2enmod کمی عجیب میاد اما باید بدونیم که این دستور مخفف جمله `apache2 enable module` هست

و برای غیر فعال کردن ماژولی مینویسیم

<div dir="ltr">

```
sudo a2dismod <module name>
```
</div>

این دستور هم مخفف جمله `apache2 disable module` هست
### چگونه از ورژن آپاچی خودمون مطلع بشویم

برای اینکار کافی هست از دستور زیر برای اینکار استفاده کنیم

<div dir="ltr">

```
sudo apachectl -v
```
</div>

## فایل های configuration  در اپاچی چیست؟

به مهم ترین بخش آپاچی وارد میشیم یعنی جایی که 90 درصد کارمون در این مکان ها هست 

آپاچی از سه فایل اصلی از شما پذیرایی میکنه برای نوشتن تمامی دستورات مورد نظر خودتون

که به شرح زیر است 

<div dir="ltr">
1- apache2.conf

2- ports.conf

3- 000-default.conf
</div>

فایل اول یا همون `apache2.conf` فایلی هست که تمامی دستورات گلوبال و عمومی آپاچی درون اونجا نوشته میشود

پس اگر یک زمانی دستوری رو میخواهیم برای همه اجرا شود رو درون این فایل مینویسیم

فایل دوم یا همون `ports.conf` فایلی هست که به ما اجازه میده برای آپاچی پورتی رو باز کنیم به طور مثال من میخوام دو وب سایت رو از یک آی پی اما با دو پورت متفاوت اجرا کنم که تمام اینها درون این مکان نوشته میشود.

و فایل آخر یا همون `000-default.conf` که مکانی برای ایجاد هر نوع وب سایت که میخواهیم بر روی سیستم لود شود و مهم ترین بخش این آپاچی محسوب میشود

آپاچی بسیار گسترده هست به همین دلیل ما بر اساس نیاز خودمون در آپاچی به جلو میریم

## چگون پورتی رو برای آپاچی باز کنیم

به طور مثال من میخوام یک وب سایت رو بر روی پورت 1875 با آی پی 192.168.1.140 باز کنم که هر کسی با این آی پی و با این پورت وارد شد منتقل بشه به دایرکتوری و یا وب سایت که من میگم

برای اینکار کافی هست که وارد این مکان بشیم `/etc/apache2/ports.conf` و در این مکان پورت مورد نظر خودمون رو تعریف کنیم

برای اینکار از دستور `Listen` استفاده میکنیم

پس مینویسیم

<div dir="ltr">

```
Listen 1875
```
</div>
یا اگر میخواهیم کمی بیشتر specific باشیم آی پی رو هم درج میکنیم

<div dir="ltr">

```
Listen 192.168.1.140:1875
```
</div>
و یا حتی میتونیم درگاه هم مشخص کنیم یعنی بگوییم که اگر فرد تنها `https` وارد کرد میتونه وارد بشه
<div dir="ltr">

```
Listen 192.168.1.140:1875 https
```
</div>

## چگونه امنیت آپاچی خود را افزایش دهیم

اولین قدم این هست که بدونیم آپاچی هنگامی که ErrorDocument یی رو نشون میده همیشه اطلاعات سیستم عامل و ورژن آپاچی مورد نظر رو نشون میده

بریم اول با دایرکتوری `conf-avaliable` و `conf-enabled` آشنا بشیم

این دو دایرکتوری درون خودشون یک سری فایل هایی برای کانفیگ کردن آپاچی دارن از جمله `security.conf` که به ما اجازه میده امنیت آپاچی رو افزایش بدیم

برای اینکار کافی بهتر هست که هر چیزی رو که نیاز داریم از اون فایل به `apache2.conf` انتقال بدیم که برای همه فعال بشه

دو چیز به نام های `ServerTokens` و `ServerSignature` رو وارد فایل `apache2.conf` میکنیم

به اینصورت
<div dir="ltr">

```
ServerSignature off
ServerTokens Prod
```
</div>
با اینکار دیگه کسی نمیتونه بفهمه که من از چه سیستم عاملی و چه آپاچی با چه ورژنی دارم استفاده میکنم

برای تست اینکار کافی هست که وارد وب سایت خودتون بشید و به اشتباه به دایرکتوری برید که وجود نداره به طور مثال

<div dir="ltr">

```
https://mixpanel.dev/info

The requested URL was not found on this server.
```
</div>
اما اگر این دو گزینه فعال نبودن به شما این اطلاعات رو میداد

<div dir="ltr">

```
https://mixpanel.dev/info

Apache/2.4.41 (Ubuntu) Server at mixpanel.dev Port 443
```
</div>

### چگونه بر روی یک Directory درون آپاچی پسورد قرار بدیم

بعضی اوقات دلمون میخواد که بتونیم یک وب سایت یا یک دایرکتوری خاص رو به شرط داشتن یوزرنیم و پسورد بتونیم دسترسی داشته باشیم و اینطوری میتونیم افراد خاص با امنیت بالا وارد بشیم

به طور مثال مثلا من دلم میخواد که بتونم از بیرون به دایرکتوریهای سرورم دست پیدا کنم ولی دلم نمیخواد هر کسی بتونه دسترسی داشته باشه پس میتونم یوزرنیم و پسورد قرار بدم

برای اینکار ابتدا باید با `Directory` آشنا بشیم

این سینتکس که خیلی هم شبیه به اچ تی ام ال هست کارش اینه که برای من محیطی رو ایجاد کنه که من بتونم دستوراتم رو به یک دایرکتوری خاص درون پروژه ای اعمال کنم

به طور مثال دلم میخواد کسی نتونه یک فایلی رو از این دایرکتوری که درون وب سایت هم هست ذخیره کنه و یا میخوام دسترسی بیشتر بدم و حتی دسترسی به Authentication برای یک بخشی از وب سایت ایجاد کنم

به طور مثال در اینجا میخواهیم کاری کنیم که فرد وقتی میخواد وارد وب سایت بشه ازش درخواست پسورد کنه پس کافی هست filesystem این پروژه رو پیدا کنیم و به دایرکتوری بدیم که بتونیم exception های خودمون رو اعمال کنیم

<div dir="ltr">

```
<Directory /mnt/d/mxplan/>
    AuthType Basic
    AuthName 'sorry you need password'
    AuthUserFile /etc/apache2/.htpasswd
    Require valid-user
</Directory>
```
</div>
در ابتدا با نوشتن `AuthType` میگیم که چه نوع از Authentication هایی میخواهیم استفاده کنیم که در اینجا Basic که یک حالت کلی هست استفاده میکنیم

سپس یک مسیجی رو تحت `AuthName` میدیم که به کاربر نشون بده

و سپس آدرس فایل `.htpasswd` رو بهش میدیم که بره گسوردی رو که یوزر داده رو با پسوردی رو که درون سرور ذخیره هست چک کنه و ببینه معتبر هست یا نه

و در نهایت به جای اینکه اجازه بدیم تمام یوزرها وارد بشن از دستور `valid-user` استفاده میکنیم که به معنی آن هست که اگر پسورد رو درست زد اون یک یوزر معتبر هست و اجازه ورود داره

### فایل .htpasswd چیست

این فایل مکانی هست که یوزرنیم و پسورد من درونش ذخیره داده شده که در سرور مورد نظر مورد استفاده قرار بگیره

برای ساخت این فایل ما نیازمند دستور `htpasswd` هستیم که بسیار ساده است

برای اینکار به اینصورت فایل مورد نظر خودمون رو میسازیم
<div dir="ltr">

```
sudo htpasswd -c /path_to/[file_name] <username>
```
</div>

دستور به اینصورت هست که ابتدا از کامند `htpasswd` استفاده میکنیم و سپس از `-c` استفاده میشود که به معنی create هست و بعد آدرس و یا نام فایل رو ایجاد میکنیم و در نهایت یوزرنیم رو وارد میکنیم

و وقتی که اینتر بزنید از شما برای وارد کردن پسورد سوال میشود که شما پسورد مورد نظر رو وارد میکنید و فایل شما برای استفاده آماده هست

<div dir="ltr">

```
sudo htpasswd -c /etc/apache2/.htpasswd illustrayking
```
</div>

### چگونه HTTP/1.1 را به HTTP/2.0 تبدیل کنیم

برای اینکه امنیت خودمون رو افزایش بدیم و از آخرین ورژن `HTTP` استفاده کنیم کافی هست که ابتدا

<div dir="ltr">

```
sudo a2enmod http2
```
</div>

فعال کنیم و بعد وارد فایل `apache2.conf` شده و به پایین ترین بخش بریم و بنویسیم

<div dir="ltr">

```
Protocols h2 http/1.1
```
</div>

اینطوری میتونیم از `HTTP/2.0` لذت ببریم

## چگونه کاری کنیم که سرور فقط با `HTTPS` ران شود

ابتدا ماژول مورد نظر رو ران میکنیم

<div dir="ltr">

```
sudo a2enmod headers
```
</div>

سپس در `virtualHost` خودمون مینویسیم

<div dir="ltr">

```
Header always set Strict-Transport-Security "max-age=63072000; includeSubDomains"
```
</div>

دستور بسیار واضح هست ابتدا به `Header` اطلاعاتی رو میفرستیم 

یعنی اطلاعاتی همچون `always set Strict-Transport-Security` یعنی همیشه از `HSTS` یا همون `HTTPS Strict Mode` استفاده کن و نزار کسی با `HTTP` متصل بشه

اینطوری باز هم امنیت رو افزایش میدیم و اینکه بهش یک زمان بالا مدت میدیم که هیچوقت `request` رو ترک نکنه

و کار بعدی که میکنه این هست که اگر `certificate` به هر دلیلی کار نکنه دیگه دستور `unsafe to dev.mixpanel.com` رو حذف میکنه و اجازه ورود نمیده

و در نهایت `includeSubDomains` که اجازه میده این قوانین رو برای تمامی زیر مجموعه ها هم اعمال کنیم

پس اگر با `curl` اطلاعات `head` رو بگیرم به شما `error` میدهد

به این شکل

![how HSTS warn you in ssl issue](/images/hsts.png)

در تصویر بالا به علت اینکه در وب سایت من مشکل SSL وجود داشت دیگه قابلیت `unsafe to <website>` رو نیورد

<div dir="ltr">

```
curl -I http://dev.mixpanel.com

HTTP/1.1 400 Bad Request
Date: Sat, 04 Jul 2020 08:56:39 GMT
Server: Apache
Content-Length: 362
Connection: close
Content-Type: text/html; charset=iso-8859-1
```
</div>

## چگونه یک  وب سایت را بر روی آپاچی نصب کنیم

قبل از هر چیزی باید بدونیم یکی دیگه از فواید آپاچی این هست که به ما اجازه میده که بتونیم بیش از یک وب سایت رو بر روی یک ip راه اندازی کنیم

که در اصطلاح میگن `virtual host` هاست مجازی که توسط این هاست ما می تونیم بیش از یک وب سایت رو بر روی یک سرور راه اندازی کنیم

ابتدا باید وارد فایل `000-default.conf` درون دایرکتوری /etc/apache2/sites-enabled وارد بشویم

کافیست توسط یک ادیتور مثل *nano* آن را باز کنیم

<div dir="ltr">

```
sudo nano /etc/apache2/sites-enabled/000-default.conf
```
</div>
قبل از هر چیزی باید بدونیم که این هم یک فایل .conf می باشد یعنی میتونیم تمامی کانفیگ های مورد نیاز خودمون رو هم درون این مکان و در یک جا بنویسیم و به جای اینکه مثلا درون فایل `apache2.conf` بنویسیم

برای اینکه بتونیم وب سایت خودمون رو ایجاد کنیم نیازمند دستور `VirtualHost` هستیم

کافی هست که این تگ رو باز کنیم و بین اون تمامی دستورات خودمون رو بنویسیم این تگ نیازمند دو چیز دیگر هم هست 

1- آی پی که ما میخواهیم روی اون وب سایت رو serve کنیم

2- پورتی که نیازمند هستیم

به طور مثال

<div dir="ltr">

```
<VirtualHost 192.168.0.50:443>

    Your host configurations sit here

</VirtualHost>
```
</div>

ما میدونیم که برای اینکه پورتی رو باز کنیم کافی هست که اون پورت رو داخل `ports.conf` بنویسیم یا بیرون از تگ `VirtualHost` اون رو بنویسیم

به این شکل 

<div dir="ltr">

```
Listen 443

<VirtualHost 192.168.0.50:443>

</VirtualHost>

or

sudo nano /etc/apache2/ports.conf

Listen 443
```
</div>

 به اولین چیزی که نیاز داریم این هست که بگیم این هاست مجازی از کدام دایرکتوری تغذیه میکنه و اصلا فایل `index.html` در کجا قرار دارد

 برای اینکار از `DocumentRoot` استفاده میکنیم

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    DocumentRoot /mnt/d/server/www/mixpanel/
</VirtualHost>
```
</div>

نیازی نیست که آدرس دقیق فایل index.html رو بدیم کافی هست که فقط آدرس دایرکتوری پروژه رو بدیم و خود آپاچی فایل مورد نظر رو لود میکنه

در قدم بعدی نیازمند `Domain name` برای آی پی حودمون هستیم چون اینطوری هم امنیت افزایش پیدا میکنه و هم به یاد مونده تر هست 

کافی هست بنویسیم

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    DocumentRoot /mnt/d/server/www/mixpanel/
    ServerName mixpanel.dev
</VirtualHost>
```
</div>
بعضی اوقات ممکن هست که میخواهیم در کنار دامین خودمون از `www` هم استفاده کنیم پس برای اینکار نیازمند `serverAlias` هستیم که بگیم اگر من از این نام هم استفاده کردم یعنی این هاست 

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    DocumentRoot /mnt/d/server/www/mixpanel/
    ServerName mixpanel.dev
    ServerAlias www.mixpanel.dev
</VirtualHost>
```
</div>

اگر در وضعیت Development هستیم و `www` کار نمیکند کاملا یک چیز طبیعی هست چرا که ما در بستر وب واقعی نیستیم و تنها داریم یک `local host` رو نزدیک میکنیم به یک وضعیت واقعی

### چگونه برای آپاچی LOG ایجاد کنیم
اگر بخواهیم بگوییم یکی از بخش های مهم آپاچی درک کردن LOG هست

ما میتونیم توی آپاچی تمام فعالیت هایی که درون وب سایت ما رخ میده رو ضبط و ثبت کنیم 

لاگ به فایلی میگویند که درون اون اطلاعاتی از فعالیت های یوزر ثبت شده مثل آی پی فرد و یا اینکه آیا موفق شده وب سایت رو لود کنه و یا نه

در کل دو مدل لاگ فایل وجود داره

 <div dir="ltr">
1- Access Log

2- Error Log
</div>
لاگ Access به لاگی میگن که اطلالاعاتی جامع در مورد ورود موفقیت آمیز کاربر به وب سایت رو گزاش میدند

2- و مهم ترین لاگ که `Error Log` هست به ما اطلاعاتی جامع در مورد مشکلاتی که کاربرها با وب سایت برخوردن رو میده و یکی از مهمترین بخش های یک آپاچی هست

برای ایجاد یک لاگ فایل دو روش رو داریم یکی `ErrorLog` و دیگری `CustomLog` هست که میتونه کمک کنه به ما در ساخت لاگ های متفاوت

به همین دلیل درون فایل آپاچی خودمون مینویسیم

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    ErrorLog /Path_to/FileName
</VirtualHost>
```
</div>
این فایل نیازمند هیچ گونه Extension یی نیست
 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    DocumentRoot /mnt/d/server/www/mixpanel/
    ServerName mixpanel.dev
    ServerAlias www.mixpanel.dev
    ErrorLog /etc/apache2/errorLog
</VirtualHost>
```
</div>

ما میتونیم حتی یک کار جالب تر رو هم انجام بدیم و اینکه به فایل خودمون فرمت خاصی رو بدیم و بگیم حتی چه چیزهایی وارد بشن و به چه شکل باشن

مثلا من دلم میخواد درون این فایل جلوی هر آی پی که میگیره بنویسه 

User Ip : Ip_address

کافی هست برای اینکار دست به `log formatting` بزنیم

برای اینکار از این روش استفاده میکنیم

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    LogFormat "format_we_want" common name
</VirtualHost>
```
</div>
برای اینکه بدونیم این فرمت لاگ برای کدوم لاگی نوشته شده از یک اسم در آخر سر استفاده میکنیم و اون رو به لاگ مورد نظر میدهیم به شکل زیر

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    LogFormat "format_we_want" common
    CustomLog /path_to/File_name common
</VirtualHost>
```
</div>
انواع مختلفی از فرمت ها رو میتونیم از لینک زیر پیدا کنیم و استفاده کنیم 

[log_format](http://httpd.apache.org/docs/current/mod/mod_log_config.html)

به طور مثال

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    DocumentRoot /mnt/d/server/www/mixpanel/
    ServerName mixpanel.dev
    ServerAlias www.mixpanel.dev
    LogFormat "LocalIP: %A Time: %t" common
    customLog /etc/apache2/custom common
</VirtualHost>
```
</div>

برای اینکه بتونیم یک `custom log` ایجاد کنیم یعنی اینکه یک لاگی که نیازداریم اطلاعاتی که ما میخواهیم درونش باشه از دستور `CustomLog` به حای `ErrorLog` استفاده میکنیم

و در آخرسر دستور `ErrorLogFormat` دستوری هست که فرمت دهی رو فقط برای `ErrorLog` ایجاد میکنه و تفاوت هاش در این هست که نیازی به اسم نداره و اینکه یک سری دستورات مثل وجود `%M` که وجود پیغام ارورو هست درون اون وجود داره

مثل مثال زیر

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    DocumentRoot /mnt/d/server/www/mixpanel/
    ServerName mixpanel.dev
    ServerAlias www.mixpanel.dev
    LogFormat "LocalIP: %A Time: %t" common
    customLog /etc/apache2/custom common
    ErrorLogFormat "Error Message: %M localIp: %A"
    ErrorLog /etc/apache2/error
</VirtualHost>
```
</div>

و در آخر سر چگونه بین پیغام های لاگ فاصله ایجاد کنیم برای اینکار کافی هست که از دستور `\t` که مخفف tab هست و یا `\n` استفاده کنیم برای اینکه به خط بعد پیغام رو بفرستیم

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    DocumentRoot /mnt/d/server/www/mixpanel/
    ServerName mixpanel.dev
    ServerAlias www.mixpanel.dev
    LogFormat "LocalIP: %A Time: %t" common
    customLog /etc/apache2/custom common
    ErrorLogFormat "Error Message: \t %M  \n localIp: %A"
    ErrorLog /etc/apache2/error
</VirtualHost>
```
</div>

## چگونه یک صفحه ErrorDocument ایجاد کنیم

یکی از مشهورترین صفحات ارور در وب سایت ها صفحه 404 یا همون `not found` هست اما اگر دلمون بخواد به جای اون اروری که خود آپاچی برای همه نوع ارورها نمایش میده یک چیز متفاوت باشه باید چیکار کنیم؟

برای اینکار نیازمند استفاده از `ErrorDocument` هستیم که آدرس داکیومنت مورد نظر رو به این دستور میدیم و میگیم مثلا هر وقت این ارور با این شماره ایجاد شد این داکیوممنت رو ظاهر کن

برای اینکار کافی هست از دستور زیر استفاده کنیم

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    ErrorDocument <ErrorNumber> /path_to/ErrorDocument
</VirtualHost>
```
</div>

به طور مثال میخوام این داکیومنت هر وقتی که ارور 404 ظاهر شد نمایان بشه

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    DocumentRoot /mnt/d/server/www/mixpanel/
    ServerName mixpanel.dev
    ServerAlias www.mixpanel.dev

    ErrorDocument 404 https://mixpanel.dev/error/404/

    LogFormat "LocalIP: %A Time: %t" common
    customLog /etc/apache2/custom common
    ErrorLogFormat "Error Message: \t %M  \n localIp: %A"
    ErrorLog /etc/apache2/error
</VirtualHost>
```
</div>
 به این شکل اگر فردی وارد دایرکتوری اشتباه بشه و این دایرکتوری وجود نداشته باشه به اون به شکلی کاملا متفاوت و خلاقانه اروری نمایش داده میشود

 برای ارورهای دیگکه هم میتونیم به طور کامل این شکل رو بسازیم و فقط کافی هست که آدرس و شماره ارور رو داشته باشیم


 ## چگونه یک وب سایت را با درگاه HTTPS لود کنیم

 این یکی از پیچیده ترین حالت هایی بود که بخاطرش حدود 2 هفته از زمانم رو درگیر مطلبش کردم و به جواب بسیار عالی رسیدم

 شاید اگر کل وب رو بگردیم کمتر بتونیم اطلاعاتی مبنی بر اینکه چطور Green padlock یا همون مفهوم قفل سبز certificate رو برای محیط development راه اندازی کنیم که من تونستم
این مشکل رو حل کنم

اما قبل از اون باید یک چیز رو خوب درک کنیم

### درگاه HTTPS چیست

ورژن بعدی HTTP که به HTTPS معروف هست به معنی `Hyper Text Transform Protocol Secure` هست که کلمه آخر اون که به معنی امنیت در ارتباط بین کاربر و سرور هست

اما چطور این امنیت رو بوجود میاره

بریم در ابتدا یک illusion رو بررسی کنیم

هنگامی که شما با مرورگر خودتون به وب متصل میشید ابتدا دستور خودتون رو به سرور مورد نظر ارسال میکنید سرور این درخواست رو دریافت میکنه و به اون جواب میده که به مفهوم همون Request/Response هست 

سپس سرور به این درخواست جواب میده 

اما آیا تا بحال به این فکر کردیم که کسی دیگه ای هم این ارسال و انتقالات رو میبینه و یا دریافت میکنه؟

بله امکان این وجود داره که یک هکر در میان این اتصال وارد بشه که معروف هستند به `man in the middle` یا همون یک فرد میانی که همانند شما در حال read کردن اطلاعاتی هست که بین شما و سرور در حال اتفاق افتادن هست

خب پس چطوری کاری کنیم که دست هکر به اطلاعات ما نرسه

به همین دلیل اومدن یک لایه به نام TLS و یا تکنولوژی قدیم اون به نام SSL رو معرفی کردن 
کلمه TLS به مفهوم `Transport Layer Security` یا همون یک لایه امن انتقال هست که وارد عمل میشه و تمامی رد و بدل های بین سرور و یوزر رو رمزنگاری میکنه و تا زمانی که کلید معتبر رو نداشته باشید امکان بازگشایی این ارسال و انتقالات وجود نداره

که این کلید معروف هست به `SSL Certificate` یا گواهینامه SSL

### SSL Certificate چیست

برای اینکه بتونیم یک ارتباط امن رو بین مرورگر و سرور ایجاد کنیم نیازمند شیوه های CryptoGraphic یا همون شیوه های رمزنگاری هستیم که شیوه ای مثل رمزنگاری با دوکلید و یا یک کلیده و غیره

در اینجا برای ایجاد ارتباط امن و اصلا ارتباط گرفتن نیازمند ساخت یک کلید pair یا همون public/private keys هستیم که کلید public به دست مرورگر میرسه و کلید private هیمشه درون سرور قرار داره که وقتی این کلید ها با هم pair میشن امکان اتصال رو بوجود میارن

اما باز هم یک سوالی که پیش میاد این هست که از کجا معلوم که کلید من به دست فرد میانی نرسیده باشه و بعد خود این فرد کلیدی رو تولید کرده باشه و اون رو به من انتقال داده باشه؟

از کجا مطمئن شویم که کلیدی که به دست من رسیده همون کلیدی هست که سرور ارسال کرده

به همین دلیل اینجا یک مطلبی بوجود میاد به نام `Certificate Authority` یا همون صادرکنندگان Certificate ها برای وب سایت ها

شما نمیتونید خودتون یک کلیدی رو بسازید و مرورگر به اون اعتماد داشته باشه حتما باید در این مکان یک فرد `نفر سوم` وجود داشته باشه که زیر گواهینامه ما امضاء کرده باشه یعنی فردی که من و شما به اون اعتماد داریم

دقیقا چیزی شبیه به دنیای واقعی

به طور مثال من رفتم از یک مغازه یک نشان پلیس و یک لباس پلیس خریدم و در خیابان رفتار یک پلیس رو انجام میدم و به همه میگم که من یک پلیس هستم

اما من از کجا اطمینان داشته باشم که شما واقعا پلیس هستید 

در این وسط باید یک شخص و یا ارگان سومی وارد بشه که من و شما به اون اطمینان داریم و شما رو تایید میکنه که گواهینامه پلیس خودش رو از شما دریافت کرده و اینطوری اطینان بین من و فرد پلیس ایجاد میشه

به همین دلیل یک سری شرکت هایی که توافق شده که به آنها اطمینان داشته باشیم برای وب سایت ها گواهینامه یا همون کلیدهای public/private` ما رو میسازند

و زیر اونها رو با نام این شرکت امضاء میکنند و خب وقتی که من درخواست خودم رو میفرستم سرور اولین چیزی رو که به من ارسال میکنه گواهینامه خودش هست

من اون رو دریافت میکنم و میبینم که نفر سوم یا همون `Issuer by` کسی هست که من هم به اون اطمینان دارم اما باز هم به گواهینامه اطمینانی ندارم

من باید این گواهینامه رو به دست شرکت مورد نظر برسونم و اگر اون شرکت اطمینان داد که این گواهینامه توسط ما صادر شده برای این سرور ارتباط امن تازه ایجاد میشه

و شما میتونید به وب سایت مورد نظر متصل بشید که در اصطلاح به این شیوه میگن `handshake` و الان ارتباط متصل شد

هنگامی که اتصال رخ داد مرورگر برای اینکه انتقال و ارسال بین سرور و یوزر رو امن کنه دو کلید که به اون کلیدها `shared keys` میگن رو میسازه و یکی از این کلیدها رو توسط همون کلیدی که از سرور دریافت کرد رمزنگاری میکنه و یا به زبان ساده تر توسط اون کلید یک قفل برای کلید خودش میسازه

و سپس کلید قفل شده رو برای سرور ارسال میکنه خب اگر این وسط فردی کلید رو بدست بیاره باز هم برای باز کردنش نیازمند کلید private سرور هست که هیچ وقت از سرور خارج نمیشه

و بعد از اینکه سرور اون کلید رو دریافت میکنه میبینه که کلید توسط کلید public| خودش رمزنگاری شده پس چون کلید اصلی رو داره میتونه قفل رو باز کنه و بعد از اون تمام انتقالات و دریافتی های بین سرور و مرورگر توسط این دو کلید رمزنگاری و رمزگشایی میشه

اینطوری ما یک ارتباط و انتقال امن رو ایجاد کردیم

#### گواهینامه Self Signed Certificate چیست

در نظر بگیرید که من در شرکت خودم و یا در خانه در حال توسعه یک اپلیکیشن و یا وب سایت در درگاه اینترنت هستم و میخوام محیط کاری خودم رو هم امن تر و هم به واقعیت بیشتر نزدیک کنم

یعنی اینکه من بتونم با domain name صفحه رو باز کنم و در محیط دولوپری خودم قفل سبز رنگ SSL رو داشته باشم

همه ما میدونیم که هیچ شرکتی برای localhost گواهینامه صادر نمیکنه به همین دلیل باید خودمون وارد عمل بشیم

اما قبل از اون باید بدونیم که هیچ مرورگری گواهینامه ای که نفر سوم یا همون Authority معتبر نداره رو به هیچ عنوان اجازه نصب نمیده که برای نصب باید حتما خودمون وارد عمل بشیم

اما گواهینامه self-signed یعنی چی

به گواهینامه ای گفته میشود که نفر سومی در کار نیست و خود فرد اون رو به امضا رسونده 

مثل این میمونه که خودم خودم رو تایید میکنم که قطعا نباید توقع این رو داشته باشم که کسی من رو باور کنه 

اما این مدل گواهینامه ها کاربردهایی دارن 

1- از این گواهینامه برای امن کردن درگاه https در محیط `interanet` میتونیم استفاده کنیم

به طور مثال مثال در نظر بگیرید که من و یک فرد دیگه از یک وب سایت برای ارتباط و انتقال استفاده میکنیم اما به network مورد نظر هیچ اطمینانی نداریم پس با رمزنگاری توسط لایه TLS ارتباطمون رو امن میکنیم

2- برای محیط تست و امن کردن development area 

متاسفانه مشکلی که پیش رو داریم این هست که هر مرورگر و یا هر نوع سیستم عامل روش های خاص خودش رو داره برای نصب این گواهینامه و آپاچی نمیتونه مستقیم خودش نصب کنه در اصل مرورگر اجازه نمیده

#### روش نصب SSL بر روی آپاچی

اگر بخواهیم به طور واقعی یک گواهینامه رو بر روی آپاچی خودمون نصب کنیم و بتونیم به درگاه https بدون دردسرر متصل بشیم باید شیوه زیر رو انجام بدیم

ابتدا باید SSL رو باید فعال کنیم 

<div dir="ltr">

```
sudo a2enmod ssl
```
</div>

سپس وارد فایل کانفیگ virtualHost میشیم و این دستورات رو مینویسیم

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    DocumentRoot /mnt/d/server/www/mixpanel/
    ServerName mixpanel.dev
    ServerAlias www.mixpanel.dev

    ErrorDocument 404 https://mixpanel.dev/error/404/

    LogFormat "LocalIP: %A Time: %t" common
    customLog /etc/apache2/custom common
    ErrorLogFormat "Error Message: \t %M  \n localIp: %A"
    ErrorLog /etc/apache2/error

    SSLEngine on
    SSLCertificateFile /path_to/certificate.crt
    SSLCertificateKeyFile /path_to/certificate.key
</VirtualHost>
```
</div>

ابتدا به هاست خودمون میگیم که موتور SSL روشن باشه اگر روشن نیست

در مرحله بعدی از دستور `SSLCertificateFile` استفاده میکنیم برای اینکه آپاچی به فایل گواهینامه که با فرمت .crt هست دسترسی داشته باشه

در مرحله آخر کلید private خودمون رو توسط دستور `SSLCertificateKeyFile` به آپاچی میدیم

به این شکل هر کسی به هاست من متصل شد آپاچی گواهینامه رو به مرورگر مورد نظر ارسال میکنه

اما این مسئله در `self signed certificate` ها حکم فرما نیست و ما نمیتونیم به این شیوه کلید مورد نظر خودمون رو به مرورگر ارسال کنیم و توقع نصب رو داشته باشیم

چرا که مرورگر وقتی میبینه که کلید مورد نظر یک کلید `self sign` هست اون رو رد میکنه

پس باید خودمون دست به کار بشیم و بر روی ماشین مورد نظر نصب کنیم

#### روش نصب یک گواهینامه self sign

قبل از هر چیزی باید بدونیم که مرورگر به مرورگر و سیستم عامل به سیستم عامل متفاوت هست اما ما تونستیم تا حدودی یک چیز راحت و سر راست رو بوجود بیاریم

مشکلات عمده 

1- موزیلا به راحتی همه چیز رو قبول نمیکنه

2- لینوکس کمی کار رو دشوار کرده

هر مرورگری دارای store گواهینامه مجزا هست یعنی هر مرورگر شیوه خودش رو داره اما درون ویندوز تنها موزیلا هست که به store سیستم عامل هیچ کاری نداره ولی ادج - کروم و اپرا از استور خود ویندوز استفاده میکنن که کار ما رو راحت میکنه

موزیلا از ورژن 64 به بعد قابلیتی رو آورد که بتونید شما کاری کنید که مرورگر به استور خود ویندوز متکی باشه

برای اینکار کافی هست داخل search bar موزیلا بنویسیم

<div dir="ltr">

```
about:config
```
</div>

و بعد که وارد شدیم به دنبال کلمه `security_enterprise_roots.enabled` رو به `True` تغییر بدیم ویاینطوری موزیلا در ویندوز از استور خود ویندوز استفاده میکنه

مشکل بعدی این هست که موزیلا بدش میاد که ببینه یک self-sign certificate دارای authority هست و خوشش نمیاد که سرش کلاه بزاریم

پس هنگامی که داریم یک گواهینامه رو برای ویندوز میسازیم این قابلیت رو باید غیرفعالش کنیم که در پایین تر مفصل صحبت خواهیم کرد

ادج و بقیه هیچ مشکلی با این مشئله ندارن که authority اون گواهینامه غیرفعال باشه پس اینجا ما با یک گواهینامه مشکلمون رو درون سیستم عامل ویندوز حل کردیم

اما اندروید و آی او اس یک گواهینامه رو درون root خودشون نصب میکنن و به اون اطمینان دارن که اون گواهینامه دارای authority باشه و اگر به هیچ عنوان به این گواهینامه اعتباری نمیدن

پس باید اینجا یک گواهینامه ای بسازیم که `Authority` اون فعال باشه پس ما اینجا مجبوریم که برای این سیستم عامل ها یک گواهینامه مجزا بسازیم و متاسفانه اینجا موزیلا کلا توی اندورید و آی او اس به مشکل میخوره

اما در لینوکس کمی قضیه متفاوت هست به اینصورت هست که هر مرورگر یک استور مجزا دارن و اصلا به استور سیستم عامل اهمیت نمیدن پس ما باید برای کروم اونی رو نصب کنیم که `authority` اون `true` هست و برای موزیلا اونی که `flase` هست رو نصب کنیم

اما در موزیلا باز هم کار به این راحتی نیست چرا که شما نمیتونید چیزی که `Authority` اون `false` هست رو نصب کنید و به شما اجازه نمیده و اگر هم اون رو `true` کنیم که بالا نمیاد

به همین دلیل نیازمند یک ترفند خاص هستیم که در بخش مورد نظر بهش میپردازیم

برای ساختن یک self-sign certificate نیازمند ابزاری به نام `openssl` هستیم که برای نصب اون از دستور
<div dir="ltr"> 

```
sudo apt install openssl -y
```
</div>

 و بعلاوه این دستور باید ابزاری به نام `certutil` که میتونیم در پکیج libsss3 پیدا کنیم 

 پس مینویسیم

 <div dir="ltr">

 ```
 sudo apt install libnss3-tools
 ```
</div>

همونطور که توضیح دادیم برای ساختن یک گواهینامه نیازمند تولید دو کلید private/public هستیم

پس برای تولید این دو کلید که یکی با فرمت `.key` که private هست و دیگری `.crt` که یک فرمت base64 هست و برای ما یک certificate رو تولید میکنه

در روش جدید دیگه ما نیاز نداریم اما درخواست ساخت یک csr بدیم و بعد توسط اون crt رو بسازیم یکراست مستقیم به ساخت crt میریم

برای ساخت گواهینامه مورد نظر ما ابتدا باید با یک فایل به `openssl.cnf` آشنا بشیم

که این فایل یک فایل خاص هست که تمامی کانفیگ هایی که ما نیاز داریم برای تولید یک گواهینامه معتبر درون اون وجود داره اما یک سری تغییراتی داده شده که بتونه به درستی کار کنه

تنها دو چیز رو باید در این فایل درک کنیم

1- alternate names

2- v3_ca extensions

مرورگرها در قدیم برای اینکه متوجه بشن شما این گواهینامه رو برای چه domain name ساختید از دستور `common name` استفاده میکردن اما بعد از مدتی سایت ها به سمتی پیش رفتن که میشد با بیش از یک domain name وارد وب سایت شد به طور مثال 

<div dir="ltr">

```
dev.mixpanel.com

mixpanel.net
```
</div>

این دو دامین یکی دارای suffix هست و دیگری دو تفاوت دارد یکی اینکه domain extension متفاوتی داره و دیگری اینکه suffix نداره

خب من دلم میخواد این گواهینامه که ماله همین وب سایت هست از هر دو دامین قابل استفاده باشه و تفاوتی اعمال نکنه

پس به همین دلیل هنگام تولید گواهینامه نیازمند این هستم که هر نوع دامینی که در حال استفاده هستم رو در بخش alterate_names بنویسم

چون وبسایت ما یک وب سایت لوکال هست پس نزامند این هستیم که بتونیم حتی از طریق آی پی هم دسترسی داشته باشیم 

پس فایل openssl.cnf رو باز میکنیم و در بخش آخر که alternate_names هست مینویسیم

<div dir="ltr">

```
sudo nano /path_to/openssl.cnf

[ alternate_names ]

DNS.1 = dev.mixpanel.com
DNS.3 = mixpanel.net
IP.1 = 192.168.0.75
IP.2 = 188.75.93.154
```
</div>

در این جا من توی این بخش به گواهینامه خودم گفتم که بدون من این گواهینامه رو برای این دامنه ها و این آی پی ها میخوام اگر یک زمانی من با این دامین و یا آی پی ها وارد شدم از همین certificate استفاده کن

همونطور که قبلا گفتم مرورگر موزیلا خوشش نمیاد که Authority اون True باشه پس به همین دلیل وارد بخش `v3_ca` میشیم و مقدار `basicConstraints`  به `FALSE` تغییر میدیم

و فایل رو سیو میکنیم و بیرون میاییم

<div dir="ltr">

```
[ v3_ca ]

basicConstraints = CA:FALSE
```
</div>

و خب الان وقت ساختن یک گواهینامه هست برای اینکار توی محیط ترمینال خودمون مینویسیم

<div dir="ltr">

```
openssl req -new -x509 -days 365 -sha256 -nodes -newkey rsa:4096 -config /path_to/openssl.cnf -keyout name_of_key.key -out name_of_certificate.crt
```
</div>

خب این دستور برای ما یک گواهینامه self-sign میسازه اما این دستورات چی هستند

دستور اول openssl که این دستور برای ساخت certificate مورد استفاده قرار میگیره

دستور دوم `req` که مشخص میکنه که درخواست ساخت دارید نه کار دیگه با این ابزار

دستور سوم `-new` مشخص میکنه که شما یک کلید جدید میخواهید 

دستور بعد `-x509` یعنی اینکه شما درخواست یک کلید `self sign certificate` کردید با ورژن 3 یا همون TLS v1.3

در هنگام ساخت یک گواهینامه شما باید به گواهینامه خودتون زمان انقضاء رو بگید مثلا در این گواهینامه من گفتم که 365 روز این گواهینامه دارای اعتبار هست

دستور `-nodes` به ما اجازه میده که بخش رمزگذاری رو گواهینامه رو غیرفعال کنیم که هر بار که آپاچی رو ری استارت کردیم از ما رمز نخواد

ما هنگام درخواست ساخت یک گواهینامه همراه اون میخواهیم کلیدها رو هم تولید کنه پس باید بهش بگیم که از چه الگوریتیمی برای رمزنگاری و رمزگشایی استفاده کنه پس از دستور
 `-newkey rsa:4096` استفاده میکنیم تا مشخص کنیم که کلید public ما طول کاراکترهاش 4096 بیت باشه و از الگوریتم rsa استفاده کنه

 دستور بعدی که مهم هم هست یعنی `-config` به ما اجازه میده که بهش بگیم از چه کانفیگ فایلی برای ساخت این گواهینامه استفاده کنه

و در نهایت از طریق `keyouy` اسم کلید private خودمون رو همراه با .key بهش میدیم و توسط دستور `out` نام گواهینامه خودمون که با فرمت `.crt` رو هم بهش میدیم

و اینطوری یک گواهینامه با CA:FALSE ساختیم

همونطور که گفتیم در دستور بعد باید CA:TRUE باشه

پس دوباره فایل رو باز میکنیم و در بخش v3_ca اون رو به TRUE تبدیل میکنیم

هنگامی که اینتر میکنیم دستور مورد نظر اطلاعاتی رو در مورد Authority از ما میخواد 

دستوراتی همچون آدرس کشور و یا شهر Authority و نام شرکت و خلاصه اطلاعات شخص تا جایی که از شما درخواست ایمیل هم میکنه

به شکل زیر

<div dir="ltr">

```
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:New York
Locality Name (eg, city) []:Brooklyn
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Example Brooklyn Company
Organizational Unit Name (eg, section) []:Technology Division
Common Name (e.g. server FQDN or YOUR name) []:examplebrooklyn.com
Email Address []:
```
</div>

همیشه یادمون باشه که نام domain خودمون رو درون common_name قرار بدیم

به طور مثال 

<div dir="ltr">

```
Common Name (e.g. server FQDN or YOUR name) []: dev.mixpanel.com
```
</div>

<div dir="ltr">

```
[ v3_ca ]

basicConstraints = CA:TRUE
```
</div>

و دوباره دستور رو اجرا میکنیم اما در یک دایرکتوری دیگه که نام های مشابه باعث از بین رفن فایل قبلی نشه و مهم تر اینکه دیگه نیازی به تولید کلید private نیست و تنها کلید قبلی رو باید بهش بدیم پس دستور در مرحله بعدی اینطوری میشه

<div dir="ltr">

```
openssl req -new -x509 -days 365 -sha256 -nodes -newkey rsa:4096 -config /path_to/openssl.cnf -key name_of_key.key -out name_of_certificate.crt
```
</div>

در این دستور به جای استفاده از keyout در این ابزار از key استفاده میکنیم و آدرس مکان کلیدی که ساختیم یا نام کلید رو بهش میدیم

در این مکان ما دو گواهینامه داریم که باید هر دوی اونها رو به آپاچی بدیم اما دستوری وجود نداره مبنی بر اینکه چطوری multiple certificate رو نصب کنیم

قبل تر از apache 2.4 دستوری به نام `SSLCertificateChainFile` وجود داشت که این امکان رو بوجود میاورد اما بعد از مدتی این دستور منسوخ شد و به جای اون آپاچی شیوه میکس کردن دو گواهینامه رو توصیه داد

چون گواهینامه ها از نوع base64 هستند پس درون text editor قابل باز شدن هستند پس توسط دستور زیر هر دو رو درون یک فایل میکنیم و اسم اون رو به طور مثال میزاریم `bundle.crt`

<div dir="ltr">

```
cat firstCertificate.crt secondCertificate.crt >> bundle.crt
```
</div>

و در نهایت این فایل رو به آپاچی میدیم و آپاچی رو ری استارت میکنیم

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    DocumentRoot /mnt/d/server/www/mixpanel/
    ServerName mixpanel.dev
    ServerAlias www.mixpanel.dev

    ErrorDocument 404 https://mixpanel.dev/error/404/

    LogFormat "LocalIP: %A Time: %t" common
    customLog /etc/apache2/custom common
    ErrorLogFormat "Error Message: \t %M  \n localIp: %A"
    ErrorLog /etc/apache2/error

    SSLEngine on
    SSLCertificateFile /path_to/bundle.crt
    SSLCertificateKeyFile /path_to/certificate.key
</VirtualHost>

sudo apachectl restart
```
</div>

#### چگونه امنیت SSL رو افزایش بدیم

بریم حالا کمی هم در مورد امنیت SSL صحبت کنیم

ابتدا فایل مورد نظر رو باز میکنیم و شروع به نوشتن این دستورات درون این فایل میکنیم

 <div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    DocumentRoot /mnt/d/server/www/mixpanel/
    ServerName mixpanel.dev
    ServerAlias www.mixpanel.dev

    ErrorDocument 404 https://mixpanel.dev/error/404/

    LogFormat "LocalIP: %A Time: %t" common
    customLog /etc/apache2/custom common
    ErrorLogFormat "Error Message: \t %M  \n localIp: %A"
    ErrorLog /etc/apache2/error

    SSLCompression off
	SSLProtocol -all +TLSv1.2 +TLSv1.3
	SSLCipherSuite EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH
	SSLHonorCipherOrder On

    SSLEngine on
    SSLCertificateFile /path_to/bundle.crt
    SSLCertificateKeyFile /path_to/certificate.key
</VirtualHost>

sudo apachectl restart
```
</div>
 
 دستور اول یعنی `SSLCompression off` به ما اجازه میده از فشرده کردن گواهینامه جلوگیری کنیم تا اینکه دست افراد غیر و هکرها به اون نرسه و حتما باید اینکار رو انجام بدیم

 دستور بعدی که خیلی هم مهم هست یعنی `SSLProtocol -all +TLSv1.2 +TLSv1.3` به معین آن هست که هر نوع گواهینامه با ورژنی رو تایید کن مگر آنکه ورژن هایی مثل SSLv2 و غیره باشن

دستور `SSLCipherSuite` برای ما باعث افزایش امنیت در رمزنگاری ها میشه این دستور اطلاعاتی رو به مرورگر میفرسته و مسگه به شرطی ارتباط به درستی متصل میشه که تو از این الگوریتم ها برای رمزنگاری استفاده کنی و یا پشتیبانی کنی 

به طور مثال AES256 و غیره و در این شرایط اجازه رمزنگاری داده میشه

 و در نهایت کاری میکنیم که همیشه Certificate از تنظیمات سرور استفاده کنه و نه کلاینت به طور مثال من به سرور خودم الگوریتم دادم ممکنه که suite کلاینت متفاوت باشه اما من میخوام از اطلاعات سرور استفاده کنه نه چیز دیگه ای 

 ## دستور Alias چیست

 دستور Alias به ما اجازه میده که بتونیم آدرس های `url` رو که به filesystem میخوان دسترسی داشته باشن رو برای آپاچی ترجمه کنیم

 به طور مثال درون فایل اچ تی ام ال خودم مینویسم `/icons/favicons.ico` این آدرس یعنی `https://dev.mixpanel.com/icons/favicons.ico` اما این برای سرور قابل فهم نیست 

 به همین دلیل باید آدرس رو به آدرس دیگه Alias کرد چرا که یک `URL` میخواد به `FileSystem` دسترسی داشته باشهنه آدرس خارجی

 پس باید بنویسیم

 <div dir="ltr">
 
 ```
 Alias /icons/ /etc/apache2/project/icons/
 ```
 </div>

اینطوری هر وقت آدرسی به این شکل برخورد میدونه یعنی کجا باید بره

## دستور Include چیست

در دستور `Include` ما میتونیم به یک کانفیگ فایل یک کانفیگ فایل دیگه attach کنیم

مثال واقعی میزنم

من دو `virtualHost` دارم که هر دو 90 درصد اطلاعاتشون شبیه به هم هست و تنها در جزئیات با هم تفاوت دارند خب برای اینکار میرم یک فایل با فرمت `conf` میسازم و دستورات رو درون اون مینویسم و بعد اون رو به هر `virtualHost` include میکنم

به این شکل

<div dir="ltr">

```
DocumentRoot /mnt/f/www/

ErrorLog /etc/apache/error

Alias /icons/ /etc/apache2/icons/
```
</div>

خب فایل بالا رو من توسط فرمت `conf` ذخیره میکنم و بعد وارد جایی که `virtualHost` های خودم رو نوشتم میشم و مینویسم

<div dir="ltr">

```
<VirtualHost 192.168.0.50:443>
    Include /etc/apache2/same.conf
</VirtualHost>

<VirtualHost 192.168.0.50:575>
    Include /etc/apache2/same.conf
</VirtualHost>
```
</div>

## چگونه ماژول gzip را برای وب سایت خود فعال کنیم

برای اینکه بتونیم تمام محتوای خودمون رو فشرده کنیم و شرایط واقعی رو بسنجیم کافی هست ابتدا ماژول `deflate` رو فعال کرده و سپس دستور زیر رو بنویسیم

<div dir="ltr">

```
sudo a2enmod deflate
```
</div>

و بعد دستور زیر رو درون `virtualHost` مورد نظر paste میکنیم

<div dir="ltr">

```
        AddOutputFilterByType DEFLATE "application/atom+xml" \
                                      "application/javascript" \
                                      "application/json" \
                                      "application/ld+json" \
                                      "application/manifest+json" \
                                      "application/rdf+xml" \
                                      "application/rss+xml" \
                                      "application/schema+json" \
                                      "application/geo+json" \
                                      "application/vnd.ms-fontobject" \
                                      "application/wasm" \
                                      "application/x-font-ttf" \
                                      "application/x-javascript" \
                                      "application/x-web-app-manifest+json" \
                                      "application/xhtml+xml" \
                                      "application/xml" \
                                      "font/eot" \
                                      "font/opentype" \
                                      "font/otf" \
                                      "font/ttf" \
                                      "image/bmp" \
                                      "image/svg+xml" \
                                      "image/vnd.microsoft.icon" \
                                      "text/cache-manifest" \
                                      "text/calendar" \
                                      "text/css" \
                                      "text/html" \
                                      "text/javascript" \
                                      "text/plain" \
                                      "text/markdown" \
                                      "text/vcard" \
                                      "text/vnd.rim.location.xloc" \
                                      "text/vtt" \
                                      "text/x-component" \
                                      "text/x-cross-domain-policy" \
                                      "text/xml"
```
</div>

توسط دستور بالا به سرور میگیم که هر وقتی این فرمت ها رو دیدی تمامشون رو به شیوه gzip فشرده سازی کن و به یوزر انتقال بده

فایل هایی از جمله `text/css, text/html, svg/xml` که میتونه خیلی توی روند سرعت وب سایت تاثیر بزاره
 ## چگونه یک صفحه index بسازیم
 صفحه index به صفحه ای میگن که به جای لود فایل index.html از طریق درگاه https به محتویات یک دایرکتوری دسترسی دارید

 شاید از خودمون بپرسیم که خب به چه دلیلی نیازمند هستیم

 یکی از اون دلیل ها میتونه این باشه که ما میتونیم امکان دانلود و آپلود از یک سرور رو برای کارکنان یک شرکت ایجاد کنیم و یا دسترسی به محتویات یک دایرکتوری رو برای محیط بیرون از شرکت ایجاد کنیم و دلایل متعدد دیگه

 
</div>